Index: src/switch_ivr_originate.c
===================================================================
--- src/switch_ivr_originate.c	(revision 5527)
+++ src/switch_ivr_originate.c	(working copy)
@@ -373,7 +373,8 @@
 		fail_on_single_reject = 1;
 	}
 
-	if ((!switch_strlen_zero(file)) && (!strcmp(file, "undef"))) {
+	/* was switch_strlen_zero(file) but newer GCC detects that file's address is always != 0 */
+	if (*file!='\0' && !strcmp(file, "undef")) {
 		*file = '\0';
 	}
 
Index: src/mod/applications/mod_commands/mod_commands.c
===================================================================
--- src/mod/applications/mod_commands/mod_commands.c	(revision 5527)
+++ src/mod/applications/mod_commands/mod_commands.c	(working copy)
@@ -1059,8 +1059,10 @@
 	}
 
 	snprintf(id, sizeof(id), "%d", holder->rows);
-	switch_xml_set_attr_d(row, "row_id", id);
 
+	/* was switch_xml_set_attr_d(row, "row_id", id); but newer GCC reports that id will always be != 0 */
+    switch_xml_set_attr(switch_xml_set_flag(row, SWITCH_XML_DUP), strdup("row_id"), strdup(id));
+
 	for(x = 0; x < argc; x++) {
 		char *name = columnNames[x];
 		char *val = switch_str_nil(argv[x]);
@@ -1229,7 +1231,8 @@
 			char count[50];
 			char *xmlstr;
 			snprintf(count, sizeof(count), "%d", holder.count);
-			switch_xml_set_attr_d(holder.xml, "row_count", count);
+			/* was switch_xml_set_attr_d(holder.xml, "row_count", count); but newer GCC reports that count is != 0 always */
+			switch_xml_set_attr(switch_xml_set_flag(holder.xml, SWITCH_XML_DUP), strdup("row_count"), strdup(count));
 			xmlstr = switch_xml_toxml(holder.xml);
 
 			if (xmlstr) {
Index: src/mod/endpoints/mod_sofia/sofia.c
===================================================================
--- src/mod/endpoints/mod_sofia/sofia.c	(revision 5527)
+++ src/mod/endpoints/mod_sofia/sofia.c	(working copy)
@@ -1785,7 +1785,8 @@
 	}
 	switch_mutex_init(&tech_pvt->flag_mutex, SWITCH_MUTEX_NESTED, switch_core_session_get_pool(session));
 
-	if (!switch_strlen_zero(key)) {
+	/* was !switch_strlen_zero(key) but newer GCC reports that key always != 0 */
+	if (*key!='\0') {
 		tech_pvt->key = switch_core_session_strdup(session, key);
 	}
 
Index: src/mod/endpoints/mod_sofia/sofia_glue.c
===================================================================
--- src/mod/endpoints/mod_sofia/sofia_glue.c	(revision 5527)
+++ src/mod/endpoints/mod_sofia/sofia_glue.c	(working copy)
@@ -581,11 +581,12 @@
 		extra_headers = stream.data;
 	}
 
+	/* newer GCC reports that rpid, alert_info and max_forwards always != 0 so replaced switch_strlen_zero */
 	nua_invite(tech_pvt->nh,
-			   TAG_IF(!switch_strlen_zero(rpid), SIPTAG_HEADER_STR(rpid)),
-			   TAG_IF(!switch_strlen_zero(alert_info), SIPTAG_HEADER_STR(alert_info)),
+			   TAG_IF(*rpid!='\0', SIPTAG_HEADER_STR(rpid)),
+			   TAG_IF(*alert_info!='\0', SIPTAG_HEADER_STR(alert_info)),
 			   TAG_IF(!switch_strlen_zero(extra_headers), SIPTAG_HEADER_STR(extra_headers)),
-			   TAG_IF(!switch_strlen_zero(max_forwards), SIPTAG_MAX_FORWARDS_STR(max_forwards)),
+			   TAG_IF(*max_forwards!='\0', SIPTAG_MAX_FORWARDS_STR(max_forwards)),
 			   SOATAG_USER_SDP_STR(tech_pvt->local_sdp_str),
 			   SOATAG_RTP_SORT(SOA_RTP_SORT_REMOTE),
 			   SOATAG_RTP_SELECT(SOA_RTP_SELECT_ALL), TAG_IF(rep, SIPTAG_REPLACES_STR(rep)), SOATAG_HOLD(holdstr), TAG_END());
@@ -629,11 +630,12 @@
 
 		nua_handle_bind(tech_pvt->nh2, tech_pvt->sofia_private);
 
+		/* newer GCC complains that rpid is always != 0 -- removed TAG_IF */
 		nua_invite(tech_pvt->nh2,
-				   TAG_IF(rpid, SIPTAG_HEADER_STR(rpid)),
-				   SIPTAG_CONTACT_STR(tech_pvt->profile->url),
-				   SOATAG_USER_SDP_STR(tech_pvt->local_sdp_str),
-				   SOATAG_RTP_SORT(SOA_RTP_SORT_REMOTE), SOATAG_RTP_SELECT(SOA_RTP_SELECT_ALL), TAG_IF(rep, SIPTAG_REPLACES_STR(rep)), TAG_END());
+			   SIPTAG_HEADER_STR(rpid),
+			   SIPTAG_CONTACT_STR(tech_pvt->profile->url),
+			   SOATAG_USER_SDP_STR(tech_pvt->local_sdp_str),
+			   SOATAG_RTP_SORT(SOA_RTP_SORT_REMOTE), SOATAG_RTP_SELECT(SOA_RTP_SELECT_ALL), TAG_IF(rep, SIPTAG_REPLACES_STR(rep)), TAG_END());
 	} else {
 		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Memory Error!\n");
 	}
Index: src/mod/endpoints/mod_sofia/sofia_presence.c
===================================================================
--- src/mod/endpoints/mod_sofia/sofia_presence.c	(revision 5527)
+++ src/mod/endpoints/mod_sofia/sofia_presence.c	(working copy)
@@ -1033,7 +1033,8 @@
 				if ((ci = switch_loadable_module_get_chat_interface(proto))) {
 					ci->chat_send(SOFIA_CHAT_PROTO, from_addr, to_addr, "", msg, full_from);
 				} else {
-					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Invalid Chat Interface [%s]!\n", proto ? proto : "(none)");
+				  /* newer GCC reports that proto will always != null so removed the test */
+					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Invalid Chat Interface [%s]!\n", proto);
 				}
 
 			}
Index: src/mod/event_handlers/mod_event_socket/mod_event_socket.c
===================================================================
--- src/mod/event_handlers/mod_event_socket/mod_event_socket.c	(revision 5527)
+++ src/mod/event_handlers/mod_event_socket/mod_event_socket.c	(working copy)
@@ -1055,7 +1055,8 @@
 				switch_clear_flag_locked(listener, LFLAG_RUNNING);
 				goto done;
 			}
-			if (!switch_strlen_zero(reply)) {
+			/* newer GCC reports that reply always != 0 removed switch_strlen_zero */
+			if (*reply!='\0') {
 				snprintf(buf, sizeof(buf), "Content-Type: command/reply\nReply-Text: %s\n\n", reply);
 				len = strlen(buf);
 				switch_socket_send(listener->sock, buf, &len);
@@ -1084,7 +1085,8 @@
 			break;
 		}
 
-		if (!switch_strlen_zero(reply)) {
+		/* newer GCC reports that reply always != 0 removed switch_strlen_zero */
+		if (*reply!='\0') {
 			snprintf(buf, sizeof(buf), "Content-Type: command/reply\nReply-Text: %s\n\n", reply);
 			len = strlen(buf);
 			switch_socket_send(listener->sock, buf, &len);
Index: src/mod/languages/mod_spidermonkey/mod_spidermonkey.c
===================================================================
--- src/mod/languages/mod_spidermonkey/mod_spidermonkey.c	(revision 5527)
+++ src/mod/languages/mod_spidermonkey/mod_spidermonkey.c	(working copy)
@@ -783,7 +783,10 @@
 
 		if ((mods = switch_xml_child(cfg, "modules"))) {
 			for (ld = switch_xml_child(mods, "load"); ld; ld = ld->next) {
-				const char *val = switch_xml_attr_soft(ld, "module");
+				/* newer GCC doesnt like pasing val because it was a const, made it non-const which is potentially bad
+				 * but that happens anyway when it goes to sm_load_module
+				 */
+				char *val = (char *)switch_xml_attr_soft(ld, "module");
 				if (strchr(val, '.') && !strstr(val, ext) && !strstr(val, EXT)) {
 					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_CONSOLE, "Invalid extension for %s\n", val);
 					continue;
@@ -1527,6 +1530,11 @@
 
 	CHANNEL_SANITY_CHECK();
 
+	if (argc < 3) {
+		*rval = BOOLEAN_TO_JSVAL(JS_FALSE);
+		return JS_FALSE;
+	}
+
 	if (argc > 0) {
 		tts_name = JS_GetStringBytes(JS_ValueToString(cx, argv[0]));
 	}
Index: src/mod/xml_int/mod_xml_rpc/mod_xml_rpc.c
===================================================================
--- src/mod/xml_int/mod_xml_rpc/mod_xml_rpc.c	(revision 5527)
+++ src/mod/xml_int/mod_xml_rpc/mod_xml_rpc.c	(working copy)
@@ -327,12 +327,14 @@
 	if (action) {
 		if (switch_core_management_exec(relative_oid, action, buf, sizeof(buf)) == SWITCH_STATUS_SUCCESS) {
 			if (action == SMA_SET) {
-				if (switch_strlen_zero(buf)) {
+				/* newer GCC claims buf always != 0, removed switch_strlen_zero */
+				if (*buf=='\0') {
 					snprintf(buf, sizeof(buf), "OK\n");
 				}
 			}
 		} else {
-			if (switch_strlen_zero(buf)) {
+			/* newer GCC claims buf always != 0, removed switch_strlen_zero */
+			if (*buf=='\0') {
 				snprintf(buf, sizeof(buf), "ERROR\n");
 			}
 		}
