diff --git a/src/mod/languages/mod_lua/Makefile.am b/src/mod/languages/mod_lua/Makefile.am
index 805b52c..e030446 100644
--- a/src/mod/languages/mod_lua/Makefile.am
+++ b/src/mod/languages/mod_lua/Makefile.am
@@ -31,5 +31,6 @@ swigclean: clean
 lua_wrap: mod_lua_extra.c
 	swig -lua -c++ -I../../../../src/include -oh mod_lua_wrap.h -o mod_lua_wrap.cpp freeswitch.i
 	echo "#include \"mod_lua_extra.c\"" >> mod_lua_wrap.cpp
+	echo "#include \"mod_lua_luasql.c\"" >> mod_lua_wrap.cpp
 	patch -s -p0 -i hack.diff
 
diff --git a/src/mod/languages/mod_lua/mod_lua.cpp b/src/mod/languages/mod_lua/mod_lua.cpp
index 3ccbef5..924ad55 100644
--- a/src/mod/languages/mod_lua/mod_lua.cpp
+++ b/src/mod/languages/mod_lua/mod_lua.cpp
@@ -37,6 +37,7 @@ SWITCH_BEGIN_EXTERN_C
 #include <lauxlib.h>
 #include <lualib.h>
 #include "mod_lua_extra.h"
+#include "mod_lua_luasql.h"
 SWITCH_MODULE_LOAD_FUNCTION(mod_lua_load);
 SWITCH_MODULE_SHUTDOWN_FUNCTION(mod_lua_shutdown);
 
@@ -126,6 +127,9 @@ static int lua_parse_and_execute(lua_State * L, char *input_code)
 		return 1;
 	}
 
+  /* Create the metatables for LuaSQL (SCSDB Driver) objects and register the driver open method */
+  luaopen_luasql_scdb(L);
+
 	if (*input_code == '~') {
 		char *buff = input_code + 1;
 		error = luaL_loadbuffer(L, buff, strlen(buff), "line") || docall(L, 0, 1);	//lua_pcall(L, 0, 0, 0);
diff --git a/src/mod/languages/mod_lua/mod_lua_luasql.c b/src/mod/languages/mod_lua/mod_lua_luasql.c
index e69de29..f0dee75 100644
--- a/src/mod/languages/mod_lua/mod_lua_luasql.c
+++ b/src/mod/languages/mod_lua/mod_lua_luasql.c
@@ -0,0 +1,490 @@
+/*
+ * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ * Copyright (C) 2005-2010, Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ *
+ * The Initial Developer of the Original Code is
+ * Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * LuaSQL 2.1.1 - Database connectivity for the Lua programming language
+ * Redesigned by Roberto Ierusalimschy, Andre Carregal and Tomas Guisasola as part of the Kepler Project
+ * Implementation by Tomas Guisasola, Eduardo Quintao, Thiago Ponte, Fabio Mascarenhas and Danilo Tuler
+ * With many contributions from Michael Broughton, Tiago Dionizio, Leonardo Godinho, Pedro Maia, Klaus Ripke, Michael Roth and others
+ * LuaSQL 1.0 was originally designed by Pedro Miller Rabinovitch and Roberto Ierusalimschy
+ *
+ * The Initial Developer of this driver is
+ * Leon de Rooij <leon@toyos.nl>
+ *
+ * Portions created by the Initial Developer are Copyright (C)
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ * Leon de Rooij <leon@toyos.nl>
+ *
+ * mod_lua_luasql.c -- LuaSQL driver for FreeSWITCH Core SQL DB
+ * Make use of the FreeSWITCH Core ODBC Cache features from inside a Lua script
+ *
+ */
+
+
+SWITCH_BEGIN_EXTERN_C
+
+
+#include <string.h>
+
+#include "lua.h"
+#include "lauxlib.h"
+
+#include "mod_lua_luasql.h"
+
+
+/*
+** Typical database error situation
+*/
+LUASQL_API int luasql_faildirect(lua_State *L, const char *err)
+{
+    lua_pushnil(L);
+    lua_pushstring(L, err);
+    return 2;
+}
+
+
+/*
+** Return the name of the object's metatable.
+** This function is used by `tostring'.
+*/
+static int luasql_tostring (lua_State *L)
+{
+  char buff[100];
+  pseudo_data *obj = (pseudo_data *)lua_touserdata (L, 1);
+  if (obj->closed)
+    strcpy (buff, "closed");
+  else
+    sprintf (buff, "%p", (void *)obj);
+  lua_pushfstring (L, "%s (%s)", lua_tostring(L,lua_upvalueindex(1)), buff);
+  return 1;
+}
+
+
+/*
+** Create a metatable and leave it on top of the stack.
+*/
+LUASQL_API int luasql_createmeta (lua_State *L, const char *name, const luaL_reg *methods)
+{
+  if (!luaL_newmetatable (L, name))
+    return 0;
+
+  /* define methods */
+  luaL_openlib (L, NULL, methods, 0);
+
+  /* define metamethods */
+  lua_pushliteral (L, "__gc");
+  lua_pushcfunction (L, methods->func);
+  lua_settable (L, -3);
+
+  lua_pushliteral (L, "__index");
+  lua_pushvalue (L, -2);
+  lua_settable (L, -3);
+
+  lua_pushliteral (L, "__tostring");
+  lua_pushstring (L, name);
+  lua_pushcclosure (L, luasql_tostring, 1);
+  lua_settable (L, -3);
+
+  lua_pushliteral (L, "__metatable");
+  lua_pushliteral (L, LUASQL_PREFIX"you're not allowed to get this metatable");
+  lua_settable (L, -3);
+
+  return 1;
+}
+
+
+/*
+** Define the metatable for the object on top of the stack
+*/
+LUASQL_API void luasql_setmeta (lua_State *L, const char *name)
+{
+  luaL_getmetatable (L, name);
+  lua_setmetatable (L, -2);
+}
+
+
+/*
+** Assumes the table is on top of the stack.
+*/
+LUASQL_API void luasql_set_info (lua_State *L)
+{
+  lua_pushliteral (L, "_COPYRIGHT");
+  lua_pushliteral (L, "Copyright (C) 2003-2007 Kepler Project");
+  lua_settable (L, -3);
+  lua_pushliteral (L, "_DESCRIPTION");
+  lua_pushliteral (L, "LuaSQL is a simple interface from Lua to a DBMS");
+  lua_settable (L, -3);
+  lua_pushliteral (L, "_VERSION");
+  lua_pushliteral (L, "LuaSQL 2.1.1");
+  lua_settable (L, -3);
+}
+
+
+
+
+
+
+/* End of copy luasql.c */
+
+
+
+
+
+
+#define LUASQL_ENVIRONMENT_SCDB "SCDB environment"
+#define LUASQL_CONNECTION_SCDB "SCDB connection"
+#define LUASQL_CURSOR_SCDB "SCDB cursor"
+
+
+typedef struct {
+  short closed;
+  int conn_counter;
+} env_data;
+
+
+typedef struct {
+  short closed;
+  int cur_counter;
+  int env;   /* reference to environment */
+  switch_cache_db_handle_t *dbh;
+} conn_data;
+
+
+/*
+** Check for valid environment.
+*/
+static env_data *getenvironment (lua_State *L)
+{
+  env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_SCDB);
+  luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+  luaL_argcheck (L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
+  return env;
+}
+
+
+/*
+** Check for valid connection.
+*/
+static conn_data *getconnection (lua_State *L)
+{
+  conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_SCDB);
+  luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+  luaL_argcheck (L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
+  return conn;
+}
+
+
+/*
+** Pushes true and returns 1
+*/
+static int pass(lua_State *L)
+{
+    lua_pushboolean (L, 1);
+    return 1;
+}
+
+
+/*
+** Closes a connection.
+*/
+static int conn_close (lua_State *L)
+{
+  env_data *env;
+  conn_data *conn = (conn_data *) luaL_checkudata(L,1,LUASQL_CONNECTION_SCDB);
+  luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+  if (conn->closed) {
+    lua_pushboolean (L, 0);
+    return 1;
+  }
+  if (conn->cur_counter > 0)
+    return luaL_error (L, LUASQL_PREFIX"there are open cursors");
+
+  /* Decrement connection counter on environment object */
+  lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
+  env = (env_data *) lua_touserdata (L, -1);
+  env->conn_counter--;
+
+  /* Nullify structure fields. */
+  conn->closed = 1;
+  luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
+  switch_cache_db_release_db_handle(&(conn->dbh));
+  return pass(L);
+}
+
+
+/*
+** Executes an SQL statement. - NOT IMPLEMENTED YET
+** Returns
+**   cursor object: if there are results or
+**   row count: number of rows affected by statement if no results
+*/
+static int conn_execute (lua_State *L)
+{
+  return luasql_faildirect (L, LUASQL_PREFIX"execute function is not implemented yet.");
+}
+
+
+/*
+** Rolls back a transaction. - NOT IMPLEMENTED YET
+*/
+static int conn_commit (lua_State *L)
+{
+  return luasql_faildirect (L, LUASQL_PREFIX"commit function is not implemented yet.");
+}
+
+
+/*
+** Rollback the current transaction. - NOT IMPLEMENTED YET
+*/
+static int conn_rollback (lua_State *L)
+{
+  return luasql_faildirect (L, LUASQL_PREFIX"rollback function is not implemented yet.");
+}
+
+
+/*
+** Sets the auto commit mode. - NOT IMPLEMENTED YET
+*/
+static int conn_setautocommit (lua_State *L)
+{
+  return luasql_faildirect (L, LUASQL_PREFIX"setautocommit function is not implemented yet.");
+}
+
+
+/*
+** Callback Struct for conn_exec2table
+*/
+typedef struct exec2table_callback_obj {
+  int rowcount;
+  lua_State *L;
+} exec2table_callback_t;
+
+
+/*
+** Callback function for conn_exec2table
+*/
+static int exec2table_callback(void *pArg, int argc, char **argv, char **columnName)
+{
+  exec2table_callback_t *cbt = (exec2table_callback_t *) pArg;
+  cbt->rowcount++;
+
+  lua_pushnumber(cbt->L, cbt->rowcount);
+
+  lua_newtable(cbt->L);
+
+  for (int i = 0; i < argc; i++) {
+    lua_pushstring(cbt->L, switch_str_nil(columnName[i]));
+    lua_pushstring(cbt->L, switch_str_nil(argv[i]));
+    lua_settable(cbt->L, -3);
+  }
+  lua_settable(cbt->L, -3);
+
+  return 0;
+}
+
+
+/*
+** Executes an SQL statement and returns the entire result set as a table
+**   NOTE: Implemented because of lack of cursor support
+**   NOTE: No native column type support - everything is a string
+** Returns
+**   table containing the entire result set
+*/
+static int conn_exec2table (lua_State *L)
+{
+  conn_data *conn = (conn_data *) getconnection (L);
+  exec2table_callback_t cbt = { 0 };
+
+  const char *statement = luaL_checkstring(L, 2);
+
+  lua_newtable(L);
+
+  cbt.rowcount = 0;
+  cbt.L = L;
+
+  if (switch_cache_db_execute_sql_callback(conn->dbh, (char *) statement,
+                   exec2table_callback, (void *) &cbt, NULL) == SWITCH_ODBC_FAIL) {
+    return luasql_faildirect (L, LUASQL_PREFIX"error while performing query.");
+  }
+
+  return 1;
+}
+
+
+/*
+** Create a new Connection object and push it on top of the stack.
+*/
+static int create_connection (lua_State *L, int o, env_data *env, switch_cache_db_handle_t *dbh)
+{
+  conn_data *conn = (conn_data *) lua_newuserdata(L, sizeof(conn_data));
+  /* set auto commit mode */
+  /* NOT IMPLEMENTED YET - But why not just BEGIN your transaction in SQL ? */
+  /*
+  SQLRETURN ret = SQLSetConnectAttr(dbh, SQL_ATTR_AUTOCOMMIT,
+    (SQLPOINTER) SQL_AUTOCOMMIT_ON, 0);
+  if (error(ret))
+    return fail(L, hDBC, dbh);
+  */
+
+  luasql_setmeta (L, LUASQL_CONNECTION_SCDB);
+
+  /* fill in structure */
+  conn->closed = 0;
+  conn->cur_counter = 0;
+  conn->env = LUA_NOREF;
+  conn->dbh = dbh;
+  lua_pushvalue (L, o);
+  conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
+  env->conn_counter++;
+  return 1;
+}
+
+
+/*
+** Creates and returns a connection object
+** Lua Input: dsn [, user [, pass]]
+**   dsn: data source name
+**   user, pass: data source authentication information
+** Lua Returns:
+**   connection object if successfull
+**   nil and error message otherwise.
+*/
+static int env_connect (lua_State *L)
+{
+  switch_cache_db_connection_options_t options = { {0} };
+  switch_cache_db_handle_t *dbh = NULL;
+
+  env_data *env = (env_data *) getenvironment (L);
+  const char *dsn  = luaL_checkstring (L, 2);
+  const char *user = luaL_optstring   (L, 3, NULL);
+  const char *pass = luaL_optstring   (L, 4, NULL);
+
+  if (zstr(dsn))
+    return luasql_faildirect (L, LUASQL_PREFIX"no dsn parameter supplied.");
+
+  options.odbc_options.dsn  = (char *) dsn;
+  options.odbc_options.user = (char *) user;
+  options.odbc_options.pass = (char *) pass;
+
+  /* try to allocate connection handle */
+  if (switch_cache_db_get_db_handle(&dbh, SCDB_TYPE_ODBC, &options) != SWITCH_STATUS_SUCCESS)
+    return luasql_faildirect (L, LUASQL_PREFIX"unable to get db handle.");
+
+  /* success, return connection object */
+  return create_connection (L, 1, env, dbh);
+}
+
+
+/*
+** Closes an environment object
+*/
+static int env_close (lua_State *L)
+{
+  env_data *env = (env_data *) luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SCDB);
+  luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+  if (env->closed) {
+    lua_pushboolean (L, 0);
+    return 1;
+  }
+  if (env->conn_counter > 0)
+    return luaL_error (L, LUASQL_PREFIX"there are open connections");
+
+  env->closed = 1;
+
+  return pass(L);
+}
+
+
+/*
+** Create metatables for each class of object.
+*/
+static void create_metatables (lua_State *L)
+{
+  struct luaL_reg environment_methods[] = {
+    {"close", env_close},
+    {"connect", env_connect},
+    {NULL, NULL},
+  };
+  struct luaL_reg connection_methods[] = {
+    {"close", conn_close},
+    {"execute", conn_execute},              /* NOT IMPLEMENTED YET */
+    {"commit", conn_commit},                /* NOT IMPLEMENTED YET */
+    {"rollback", conn_rollback},            /* NOT IMPLEMENTED YET */
+    {"setautocommit", conn_setautocommit},  /* NOT IMPLEMENTED YET */
+    {"exec2table", conn_exec2table},
+    {NULL, NULL},
+  };
+  struct luaL_reg cursor_methods[] = {
+/*    {"close", cur_close},           */    /* NOT IMPLEMENTED YET */
+/*    {"fetch", cur_fetch},           */    /* NOT IMPLEMENTED YET */
+/*    {"getcoltypes", cur_coltypes},  */    /* NOT IMPLEMENTED YET */
+/*    {"getcolnames", cur_colnames},  */    /* NOT IMPLEMENTED YET */
+    {NULL, NULL},
+  };
+  luasql_createmeta (L, LUASQL_ENVIRONMENT_SCDB, environment_methods);
+  luasql_createmeta (L, LUASQL_CONNECTION_SCDB, connection_methods);
+  luasql_createmeta (L, LUASQL_CURSOR_SCDB, cursor_methods);
+  lua_pop (L, 3);
+}
+
+
+/*
+** Creates an Environment and returns it.
+*/
+static int create_environment (lua_State *L)
+{
+  if (!switch_odbc_available()) {
+    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "No core ODBC available.\n");
+    return luasql_faildirect (L, LUASQL_PREFIX"No core ODBC available.");
+  }
+
+  create_metatables (L); /* was in luaopen_luasql_scdb below, is it alright here ? */
+
+  env_data *env = (env_data *) lua_newuserdata(L, sizeof(env_data));
+  luasql_setmeta(L, LUASQL_ENVIRONMENT_SCDB);
+
+  /* fill in structure */
+  env->closed = 0;
+  env->conn_counter = 0;
+  return 1;
+}
+
+
+/*
+** Creates the metatables for the objects and registers the
+** driver open method.
+*/
+LUASQL_API int luaopen_luasql_scdb (lua_State *L)
+{
+  struct luaL_reg driver[] = {
+    {"scdb", create_environment},
+    {NULL, NULL},
+  };
+  /* create_metatables (L); // this was done here, moved to create_environment, but will it affect gc ? */
+  luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
+  luasql_set_info (L);
+
+  return 1;
+}
+
+
+SWITCH_END_EXTERN_C
diff --git a/src/mod/languages/mod_lua/mod_lua_luasql.h b/src/mod/languages/mod_lua/mod_lua_luasql.h
index e69de29..6f12aef 100644
--- a/src/mod/languages/mod_lua/mod_lua_luasql.h
+++ b/src/mod/languages/mod_lua/mod_lua_luasql.h
@@ -0,0 +1,27 @@
+#ifndef MOD_LUA_LUASQL
+#define MOD_LUA_LUASQL
+SWITCH_BEGIN_EXTERN_C
+
+#ifndef LUASQL_API
+#define LUASQL_API
+#endif
+
+#define LUASQL_PREFIX "LuaSQL: "
+#define LUASQL_TABLENAME "luasql"
+#define LUASQL_ENVIRONMENT "Each driver must have an environment metatable"
+#define LUASQL_CONNECTION "Each driver must have a connection metatable"
+#define LUASQL_CURSOR "Each driver must have a cursor metatable"
+
+typedef struct {
+  short  closed;
+} pseudo_data;
+
+LUASQL_API int luasql_faildirect (lua_State *L, const char *err);
+LUASQL_API int luasql_createmeta (lua_State *L, const char *name, const luaL_reg *methods);
+LUASQL_API void luasql_setmeta (lua_State *L, const char *name);
+LUASQL_API void luasql_set_info (lua_State *L);
+
+LUASQL_API int luaopen_luasql_scdb (lua_State *L);
+
+SWITCH_END_EXTERN_C
+#endif
diff --git a/src/mod/languages/mod_lua/mod_lua_wrap.cpp b/src/mod/languages/mod_lua/mod_lua_wrap.cpp
index bdb5097..e19cf0f 100644
--- a/src/mod/languages/mod_lua/mod_lua_wrap.cpp
+++ b/src/mod/languages/mod_lua/mod_lua_wrap.cpp
@@ -7463,3 +7463,4 @@ void SWIG_init_user(lua_State* L)
 }
 
 #include "mod_lua_extra.c"
+#include "mod_lua_luasql.c"
