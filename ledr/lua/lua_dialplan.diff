Index: src/mod/languages/mod_lua/mod_lua.cpp
===================================================================
--- src/mod/languages/mod_lua/mod_lua.cpp	(revision 15327)
+++ src/mod/languages/mod_lua/mod_lua.cpp	(working copy)
@@ -461,10 +461,80 @@
 	return SWITCH_STATUS_SUCCESS;
 }
 
+SWITCH_STANDARD_DIALPLAN(lua_dialplan_hunt)
+{
+	lua_State *L = lua_init();
+	switch_caller_extension_t *extension = NULL;
+	switch_channel_t *channel = switch_core_session_get_channel(session);
+	char *cmd;
+	char *str;
+
+	if (!caller_profile) {
+		if (!(caller_profile = switch_channel_get_caller_profile(channel))) {
+			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, "Error Obtaining Profile!\n");
+			goto done;
+		}
+	}
+
+	if (!caller_profile->context) {
+		caller_profile->context = "lua/dialplan.lua";
+	}
+
+	switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_INFO, "Processing %s->%s in context/script %s\n",
+	          caller_profile->caller_id_name, caller_profile->destination_number, caller_profile->context);
+
+	if ((extension = switch_caller_extension_new(session, "_anon_", caller_profile->destination_number)) == 0) {
+		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_CRIT, "Memory Error!\n");
+		goto done;
+	}
+
+	cmd = strdup(caller_profile->context);
+	switch_assert(cmd);
+
+	mod_lua_conjure_session(L, session, "session", 1);
+	lua_parse_and_execute(L, cmd);
+
+	/* expecting APPS = { "application1", "app_data1", "application2", "app_data2", "application3" } */
+	lua_getfield(L, LUA_GLOBALSINDEX, "APPS");
+	if (lua_istable(L, 1)) {
+		lua_pushnil(L);  /* first key */
+		while (lua_next(L, 1) != 0) {
+			/* uses 'key' (at index -2) and 'value' (at index -1) */
+			if (lua_isstring(L, -1)) {
+				char *application;
+				char *app_data;
+		 		application = strdup(lua_tostring(L, -1));
+				lua_pop(L, 1);
+				if (lua_next(L, 1) != 0) {
+					if (lua_isstring(L, -1)) {
+						app_data = strdup(lua_tostring(L, -1));
+					} else {
+						switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, "Each app_data must be returned as a string!\n");
+					}
+				}
+				switch_caller_extension_add_application(session, extension, application, app_data);
+				switch_safe_free(app_data);
+				switch_safe_free(application);
+			} else {
+				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, "Each application must be returned as a string!\n");
+			}
+			/* removes 'value'; keeps 'key' for next iteration */
+			lua_pop(L, 1);
+		}
+
+	}
+
+ done:
+	switch_safe_free(cmd);
+	lua_uninit(L);
+	return extension;
+}
+
 SWITCH_MODULE_LOAD_FUNCTION(mod_lua_load)
 {
 	switch_api_interface_t *api_interface;
 	switch_application_interface_t *app_interface;
+	switch_dialplan_interface_t *dp_interface;
 
 	/* connect my internal structure to the blank pointer passed to me */
 	*module_interface = switch_loadable_module_create_module_interface(pool, modname);
@@ -472,6 +542,7 @@
 	SWITCH_ADD_API(api_interface, "luarun", "run a script", luarun_api_function, "<script>");
 	SWITCH_ADD_API(api_interface, "lua", "run a script as an api function", lua_api_function, "<script>");
 	SWITCH_ADD_APP(app_interface, "lua", "Launch LUA ivr", "Run a lua ivr on a channel", lua_function, "<script>", SAF_SUPPORT_NOMEDIA);
+	SWITCH_ADD_DIALPLAN(dp_interface, "LUA", lua_dialplan_hunt);
 
 
 
